import numpy as numpy
from stable_baselines.common.replay_buffer import ReplayBuffer
from abc import ABC, abstractmethod

class AbstractLandmarkGenerator(ABC):
  """
  Defines interface for landmark generators
  """

  def __init__(self, buffer_size, env):
    self.buffer_size = buffer_size
    self.ob_space = env.observation_space.spaces['observation']
    self.goal_space = env.observation_space.spaces['achieved_goal']
    if not env.goal_extraction_function:
      raise ValueError("Environment must have goal_extraction_function method")
    self.goal_extraction_function = env.goal_extraction_function

    self.states = None
    self.landmark_states = None
    self.goals = None

  @abstractmethod
  def add_state_data(self, states, achieved_goals):
    """
    Processes state / achieved_goal data.
    """
    raise NotImplementedError

  @abstractmethod
  def generate(self, states, goals):
    """Generates landmarks for states and goals.

    :param states: (batch_size * state_dim vector)
    :param goals: (batch_size * goal_dim vector)
    :return landmarks: (tuple of (landmark_states, landmark_goals))
    """
    raise NotImplementedError

  @abstractmethod
  def assign_scores(self, scores):
    """Assigns scores to the landmarks previously generated by generate method."""
    raise NotImplementedError

class RandomLandmarkGenerator(AbstractLandmarkGenerator):
  def __init__(self, buffer_size, env):
    super().__init__(buffer_size, env)
    self.state_buffer = ReplayBuffer(self.buffer_size, [("state", self.ob_space.shape)])
    if self.goal_extraction_function is None:
      raise ValueError("Random generator requires a goal_extraction function!")
  
  def add_state_data(self, states, goals):
    self.state_buffer.add_batch(states)

  def generate(self, states, goals):
    self.landmark_states = landmark_states = self.state_buffer.sample(len(states))[0]
    landmark_goals = self.goal_extraction_function(landmark_states)
    self.states = states
    self.goals = goals

    return landmark_states, landmark_goals

  def assign_scores(self, scores):
    # Do Nothing (random generator does not learn)
    pass

class NearestNeighborLandmarkGenerator(AbstractLandmarkGenerator):
  def __init__(self, buffer_size, env):
    super().__init__(buffer_size, env)
    self.state_buffer = ReplayBuffer(self.buffer_size, [("state", self.ob_space.shape)])
    if self.goal_extraction_function is None:
      raise ValueError("Random generator requires a goal_extraction function!")
